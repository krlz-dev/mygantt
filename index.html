<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SimpleGantt</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.1/font/bootstrap-icons.css" rel="stylesheet">
    <style>
        :root {
            --primary: #4f46e5;
            --primary-light: #818cf8;
            --sidebar-width: 300px;
            --row-height: 44px;
            --header-height: 60px;
            --timeline-header: 50px;
        }

        * { box-sizing: border-box; }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: #f8fafc;
            overflow: hidden;
        }

        /* Header */
        .app-header {
            height: var(--header-height);
            background: white;
            border-bottom: 1px solid #e2e8f0;
            display: flex;
            align-items: center;
            padding: 0 20px;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 100;
        }

        .app-header h1 {
            font-size: 1.25rem;
            font-weight: 700;
            color: var(--primary);
            margin: 0;
        }

        .app-header .btn-add {
            background: var(--primary);
            border: none;
            padding: 8px 16px;
            font-size: 0.875rem;
        }

        .app-header .btn-add:hover {
            background: var(--primary-light);
        }

        .app-header .btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        /* Main Container */
        .gantt-container {
            display: flex;
            margin-top: var(--header-height);
            height: calc(100vh - var(--header-height));
        }

        /* Task Sidebar */
        .task-sidebar {
            width: var(--sidebar-width);
            min-width: 200px;
            max-width: 600px;
            background: white;
            border-right: 2px solid #e2e8f0;
            display: flex;
            flex-direction: column;
            position: relative;
        }

        .sidebar-resize-handle {
            position: absolute;
            top: 0;
            right: 0;
            width: 6px;
            height: 100%;
            cursor: ew-resize;
            background: transparent;
            z-index: 10;
            transition: background 0.2s;
        }

        .sidebar-resize-handle:hover {
            background: #818cf8;
        }

        .sidebar-resize-handle:active {
            background: #4f46e5;
        }

        .sidebar-header {
            height: var(--timeline-header);
            border-bottom: 1px solid #e2e8f0;
            display: flex;
            align-items: center;
            padding: 0 16px;
            font-weight: 600;
            color: #64748b;
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .task-list { flex: 1; overflow-y: auto; }

        .task-row {
            height: var(--row-height);
            display: flex;
            align-items: center;
            padding: 0 8px 0 16px;
            border-bottom: 1px solid #f1f5f9;
            cursor: pointer;
            transition: background 0.15s;
        }

        .task-row:hover { background: #f8fafc; }
        .task-row.group { background: #f1f5f9; font-weight: 600; }

        .task-row .task-icon {
            width: 20px;
            margin-right: 8px;
            color: #94a3b8;
        }

        .task-row .task-name {
            flex: 1;
            font-size: 0.875rem;
            color: #1e293b;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .task-row .task-actions {
            display: none;
            gap: 4px;
        }

        .task-row:hover .task-actions { display: flex; }
        .task-row:hover .task-assignee { display: none; }

        .task-row .task-actions .btn {
            padding: 2px 6px;
            font-size: 0.75rem;
        }

        .task-row .task-assignee {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            background: var(--primary-light);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.7rem;
            font-weight: 600;
        }

        /* Timeline Area */
        .timeline-area {
            flex: 1;
            overflow-x: auto;
            overflow-y: auto;
            position: relative;
        }

        .timeline-wrapper {
            min-width: 100%;
            position: relative;
        }

        /* Timeline Header */
        .timeline-header {
            height: var(--timeline-header);
            background: white;
            border-bottom: 1px solid #e2e8f0;
            display: flex;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        .timeline-month {
            text-align: center;
            border-right: 1px solid #e2e8f0;
        }

        .timeline-month-name {
            font-size: 0.75rem;
            font-weight: 600;
            color: #64748b;
            padding: 4px 0;
            border-bottom: 1px solid #f1f5f9;
        }

        .timeline-days { display: flex; }

        .timeline-day {
            flex: 1;
            min-width: 36px;
            text-align: center;
            font-size: 0.7rem;
            color: #94a3b8;
            padding: 4px 0;
        }

        .timeline-day.weekend { background: #fafafa; color: #cbd5e1; }
        .timeline-day.today { background: #eef2ff; color: var(--primary); font-weight: 600; }

        /* Timeline Body */
        .timeline-body { position: relative; }

        .timeline-row {
            height: var(--row-height);
            border-bottom: 1px solid #f1f5f9;
            position: relative;
            display: flex;
        }

        .timeline-row.group { background: #f8fafc; }

        .timeline-cell {
            flex: 1;
            min-width: 36px;
            border-right: 1px solid #f1f5f9;
        }

        .timeline-cell.weekend { background: #fafafa; }
        .timeline-cell.today { background: #eef2ff; }

        /* Gantt Bars */
        .gantt-bar {
            position: absolute;
            height: 24px;
            top: 10px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            padding: 0 8px;
            font-size: 0.75rem;
            color: white;
            font-weight: 500;
            cursor: grab;
            transition: box-shadow 0.15s;
            z-index: 5;
            user-select: none;
        }

        .gantt-bar:hover { box-shadow: 0 4px 12px rgba(0,0,0,0.15); }
        .gantt-bar.dragging { cursor: grabbing; opacity: 0.8; z-index: 20; }

        .gantt-bar.blue { background: linear-gradient(135deg, #3b82f6, #2563eb); }
        .gantt-bar.green { background: linear-gradient(135deg, #22c55e, #16a34a); }
        .gantt-bar.purple { background: linear-gradient(135deg, #8b5cf6, #7c3aed); }
        .gantt-bar.orange { background: linear-gradient(135deg, #f97316, #ea580c); }
        .gantt-bar.pink { background: linear-gradient(135deg, #ec4899, #db2777); }
        .gantt-bar.teal { background: linear-gradient(135deg, #14b8a6, #0d9488); }

        .gantt-bar .progress-fill {
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            background: rgba(255,255,255,0.25);
            border-radius: 4px 0 0 4px;
            pointer-events: none;
        }

        .gantt-bar .bar-label {
            position: relative;
            z-index: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            pointer-events: none;
        }

        /* Resize Handles */
        .gantt-bar .resize-handle {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 8px;
            cursor: ew-resize;
        }

        .gantt-bar .resize-handle.left { left: 0; }
        .gantt-bar .resize-handle.right { right: 0; }

        /* Group Bar */
        .gantt-bar.group-bar {
            height: 8px;
            top: 18px;
            background: #475569;
            border-radius: 2px;
            cursor: default;
        }

        .gantt-bar.group-bar::before,
        .gantt-bar.group-bar::after {
            content: '';
            position: absolute;
            bottom: -4px;
            width: 8px;
            height: 8px;
            background: #475569;
        }

        .gantt-bar.group-bar::before { left: 0; clip-path: polygon(0 0, 100% 0, 50% 100%); }
        .gantt-bar.group-bar::after { right: 0; clip-path: polygon(0 0, 100% 0, 50% 100%); }

        /* Milestone */
        .milestone {
            position: absolute;
            width: 20px;
            height: 20px;
            top: 12px;
            background: #f97316;
            transform: rotate(45deg);
            border-radius: 3px;
            cursor: pointer;
            z-index: 5;
        }

        /* Dependencies SVG */
        .dependencies-layer {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            z-index: 4;
        }

        .dependency-line {
            fill: none;
            stroke: #94a3b8;
            stroke-width: 2;
            marker-end: url(#arrowhead);
        }

        /* Today Line */
        .today-line {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 2px;
            background: #ef4444;
            z-index: 6;
            pointer-events: none;
        }

        .today-line::before {
            content: 'Today';
            position: absolute;
            top: -20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.65rem;
            color: #ef4444;
            font-weight: 600;
            white-space: nowrap;
        }

        /* Modal customizations */
        .modal-header { border-bottom: 1px solid #e2e8f0; }
        .modal-footer { border-top: 1px solid #e2e8f0; }

        .color-picker {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .color-option {
            width: 32px;
            height: 32px;
            border-radius: 6px;
            cursor: pointer;
            border: 3px solid transparent;
            transition: transform 0.15s;
        }

        .color-option:hover { transform: scale(1.1); }
        .color-option.selected { border-color: #1e293b; }

        .color-option.blue { background: linear-gradient(135deg, #3b82f6, #2563eb); }
        .color-option.green { background: linear-gradient(135deg, #22c55e, #16a34a); }
        .color-option.purple { background: linear-gradient(135deg, #8b5cf6, #7c3aed); }
        .color-option.orange { background: linear-gradient(135deg, #f97316, #ea580c); }
        .color-option.pink { background: linear-gradient(135deg, #ec4899, #db2777); }
        .color-option.teal { background: linear-gradient(135deg, #14b8a6, #0d9488); }

        /* Scrollbar */
        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: #f1f5f9; }
        ::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #94a3b8; }

        /* Toast */
        .toast-container { z-index: 1100; }
    </style>
</head>
<body>
    <!-- Header -->
    <header class="app-header">
        <h1><i class="bi bi-bar-chart-steps me-2"></i>SimpleGantt</h1>
        <div class="ms-auto d-flex gap-2">
            <button class="btn btn-outline-secondary btn-sm" id="undoBtn" onclick="undo()" title="Undo (Ctrl+Z)" disabled>
                <i class="bi bi-arrow-counterclockwise"></i>
            </button>
            <button class="btn btn-outline-secondary btn-sm" id="redoBtn" onclick="redo()" title="Redo (Ctrl+Y)" disabled>
                <i class="bi bi-arrow-clockwise"></i>
            </button>
            <div class="dropdown">
                <button class="btn btn-outline-secondary btn-sm dropdown-toggle" data-bs-toggle="dropdown" id="viewModeBtn">
                    <i class="bi bi-calendar-range"></i> <span id="viewModeLabel">Days</span>
                </button>
                <ul class="dropdown-menu">
                    <li><a class="dropdown-item" href="#" onclick="changeView('days')">Days</a></li>
                    <li><a class="dropdown-item" href="#" onclick="changeView('weeks')">Weeks</a></li>
                    <li><a class="dropdown-item" href="#" onclick="changeView('months')">Months</a></li>
                    <li><a class="dropdown-item" href="#" onclick="changeView('quarters')">Quarters</a></li>
                    <li><a class="dropdown-item" href="#" onclick="changeView('semesters')">Semesters</a></li>
                    <li><a class="dropdown-item" href="#" onclick="changeView('years')">Years</a></li>
                </ul>
            </div>
            <button class="btn btn-outline-secondary btn-sm" onclick="scrollToToday()">
                <i class="bi bi-calendar3"></i> Today
            </button>
            <div class="dropdown">
                <button class="btn btn-outline-secondary btn-sm dropdown-toggle" data-bs-toggle="dropdown">
                    <i class="bi bi-gear"></i>
                </button>
                <ul class="dropdown-menu dropdown-menu-end">
                    <li><h6 class="dropdown-header">Export Image</h6></li>
                    <li><a class="dropdown-item" href="#" onclick="exportAsPNG()"><i class="bi bi-file-image me-2"></i>Export as PNG</a></li>
                    <li><a class="dropdown-item" href="#" onclick="exportAsSVG()"><i class="bi bi-filetype-svg me-2"></i>Export as SVG</a></li>
                    <li><hr class="dropdown-divider"></li>
                    <li><h6 class="dropdown-header">Project Data</h6></li>
                    <li><a class="dropdown-item" href="#" onclick="exportData()"><i class="bi bi-download me-2"></i>Export JSON</a></li>
                    <li><a class="dropdown-item" href="#" onclick="document.getElementById('importFile').click()"><i class="bi bi-upload me-2"></i>Import JSON</a></li>
                    <li><hr class="dropdown-divider"></li>
                    <li><a class="dropdown-item text-danger" href="#" onclick="clearAllData()"><i class="bi bi-trash me-2"></i>Clear All</a></li>
                </ul>
            </div>
            <input type="file" id="importFile" accept=".json" style="display:none" onchange="importData(event)">
            <button class="btn btn-add btn-primary btn-sm text-white" onclick="openTaskModal()">
                <i class="bi bi-plus-lg me-1"></i> Add Task
            </button>
        </div>
    </header>

    <!-- Main Gantt Container -->
    <div class="gantt-container">
        <div class="task-sidebar" id="taskSidebar">
            <div class="sidebar-header">
                <span>Task Name</span>
                <span class="ms-auto">Assignee</span>
            </div>
            <div class="task-list" id="taskList"></div>
            <div class="sidebar-resize-handle" id="sidebarResizeHandle"></div>
        </div>

        <div class="timeline-area" id="timelineArea">
            <div class="timeline-wrapper" id="timelineWrapper">
                <div class="timeline-header" id="timelineHeader"></div>
                <div class="timeline-body" id="timelineBody">
                    <svg class="dependencies-layer" id="dependenciesLayer">
                        <defs>
                            <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                                <polygon points="0 0, 10 3.5, 0 7" fill="#94a3b8" />
                            </marker>
                        </defs>
                    </svg>
                </div>
            </div>
        </div>
    </div>

    <!-- Task Modal -->
    <div class="modal fade" id="taskModal" tabindex="-1">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="taskModalTitle">Add Task</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                </div>
                <div class="modal-body">
                    <input type="hidden" id="taskId">
                    <div class="mb-3">
                        <label class="form-label">Task Name</label>
                        <input type="text" class="form-control" id="taskName" required>
                    </div>
                    <div class="mb-3">
                        <label class="form-label">Type</label>
                        <select class="form-select" id="taskType" onchange="toggleTaskFields()">
                            <option value="task">Task</option>
                            <option value="group">Group</option>
                            <option value="milestone">Milestone</option>
                        </select>
                    </div>
                    <div class="row mb-3" id="dateFields">
                        <div class="col">
                            <label class="form-label">Start Date</label>
                            <input type="date" class="form-control" id="taskStart">
                        </div>
                        <div class="col" id="endDateCol">
                            <label class="form-label">End Date</label>
                            <input type="date" class="form-control" id="taskEnd">
                        </div>
                    </div>
                    <div id="taskFields">
                        <div class="mb-3">
                            <label class="form-label">Assignee (initials)</label>
                            <input type="text" class="form-control" id="taskAssignee" maxlength="3" placeholder="e.g. JD">
                        </div>
                        <div class="mb-3">
                            <label class="form-label">Progress: <span id="progressValue">0</span>%</label>
                            <input type="range" class="form-range" id="taskProgress" min="0" max="100" value="0" oninput="document.getElementById('progressValue').textContent=this.value">
                        </div>
                        <div class="mb-3">
                            <label class="form-label">Color</label>
                            <div class="color-picker" id="colorPicker">
                                <div class="color-option blue selected" data-color="blue"></div>
                                <div class="color-option green" data-color="green"></div>
                                <div class="color-option purple" data-color="purple"></div>
                                <div class="color-option orange" data-color="orange"></div>
                                <div class="color-option pink" data-color="pink"></div>
                                <div class="color-option teal" data-color="teal"></div>
                            </div>
                        </div>
                        <div class="mb-3">
                            <label class="form-label">Depends On</label>
                            <select class="form-select" id="taskDependency">
                                <option value="">None</option>
                            </select>
                        </div>
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-danger me-auto" id="deleteTaskBtn" onclick="deleteTask()" style="display:none">
                        <i class="bi bi-trash"></i> Delete
                    </button>
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                    <button type="button" class="btn btn-primary" onclick="saveTask()">Save</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Toast -->
    <div class="toast-container position-fixed bottom-0 end-0 p-3">
        <div id="toast" class="toast" role="alert">
            <div class="toast-body d-flex align-items-center">
                <span id="toastMessage"></span>
                <button type="button" class="btn-close ms-auto" data-bs-dismiss="toast"></button>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        // Config
        const dayWidth = 36;
        const rowHeight = 44;
        const STORAGE_KEY = 'simplegantt_data';
        const SETTINGS_KEY = 'simplegantt_settings';

        // View configurations - defines how each view scale works
        const viewConfig = {
            days: {
                label: 'Days',
                cellWidth: 36,
                getUnits: (start, end) => {
                    const units = [];
                    for (let d = new Date(start); d <= end; d.setDate(d.getDate() + 1)) {
                        units.push({
                            date: new Date(d),
                            label: d.getDate().toString(),
                            isWeekend: d.getDay() === 0 || d.getDay() === 6,
                            isToday: d.toDateString() === today.toDateString(),
                            month: d.toLocaleString('default', { month: 'short' }),
                            year: d.getFullYear()
                        });
                    }
                    return units;
                },
                getDuration: (start, end) => daysBetween(start, end) + 1
            },
            weeks: {
                label: 'Weeks',
                cellWidth: 60,
                getUnits: (start, end) => {
                    const units = [];
                    let current = new Date(start);
                    // Start from beginning of week (Monday)
                    current.setDate(current.getDate() - (current.getDay() || 7) + 1);

                    while (current <= end) {
                        const weekEnd = new Date(current);
                        weekEnd.setDate(weekEnd.getDate() + 6);
                        const weekNum = getWeekNumber(current);

                        units.push({
                            date: new Date(current),
                            endDate: weekEnd,
                            label: `W${weekNum}`,
                            month: current.toLocaleString('default', { month: 'short' }),
                            year: current.getFullYear()
                        });
                        current.setDate(current.getDate() + 7);
                    }
                    return units;
                },
                getDuration: (start, end) => {
                    const weeks = Math.ceil(daysBetween(start, end) / 7);
                    return weeks;
                }
            },
            months: {
                label: 'Months',
                cellWidth: 80,
                getUnits: (start, end) => {
                    const units = [];
                    let current = new Date(start.getFullYear(), start.getMonth(), 1);

                    while (current <= end) {
                        units.push({
                            date: new Date(current),
                            label: current.toLocaleString('default', { month: 'short' }),
                            year: current.getFullYear()
                        });
                        current.setMonth(current.getMonth() + 1);
                    }
                    return units;
                },
                getDuration: (start, end) => {
                    return (end.getFullYear() - start.getFullYear()) * 12 + end.getMonth() - start.getMonth() + 1;
                }
            },
            quarters: {
                label: 'Quarters',
                cellWidth: 100,
                getUnits: (start, end) => {
                    const units = [];
                    let current = new Date(start.getFullYear(), Math.floor(start.getMonth() / 3) * 3, 1);

                    while (current <= end) {
                        const quarter = Math.floor(current.getMonth() / 3) + 1;
                        units.push({
                            date: new Date(current),
                            label: `Q${quarter}`,
                            year: current.getFullYear()
                        });
                        current.setMonth(current.getMonth() + 3);
                    }
                    return units;
                },
                getDuration: (start, end) => {
                    const startQ = Math.floor(start.getMonth() / 3);
                    const endQ = Math.floor(end.getMonth() / 3);
                    return (end.getFullYear() - start.getFullYear()) * 4 + endQ - startQ + 1;
                }
            },
            semesters: {
                label: 'Semesters',
                cellWidth: 120,
                getUnits: (start, end) => {
                    const units = [];
                    let current = new Date(start.getFullYear(), Math.floor(start.getMonth() / 6) * 6, 1);

                    while (current <= end) {
                        const semester = Math.floor(current.getMonth() / 6) + 1;
                        units.push({
                            date: new Date(current),
                            label: `S${semester}`,
                            year: current.getFullYear()
                        });
                        current.setMonth(current.getMonth() + 6);
                    }
                    return units;
                },
                getDuration: (start, end) => {
                    const startS = Math.floor(start.getMonth() / 6);
                    const endS = Math.floor(end.getMonth() / 6);
                    return (end.getFullYear() - start.getFullYear()) * 2 + endS - startS + 1;
                }
            },
            years: {
                label: 'Years',
                cellWidth: 150,
                getUnits: (start, end) => {
                    const units = [];
                    let current = new Date(start.getFullYear(), 0, 1);

                    while (current <= end) {
                        units.push({
                            date: new Date(current),
                            label: current.getFullYear().toString(),
                            year: current.getFullYear()
                        });
                        current.setFullYear(current.getFullYear() + 1);
                    }
                    return units;
                },
                getDuration: (start, end) => {
                    return end.getFullYear() - start.getFullYear() + 1;
                }
            }
        };

        // State
        let tasks = [];
        let startDate = new Date();
        let endDate = new Date();
        let today = new Date();
        today.setHours(0, 0, 0, 0);
        let currentView = 'days';
        let sidebarWidth = 300;

        // Undo/Redo state
        let historyPast = [];
        let historyFuture = [];
        const MAX_HISTORY = 50;

        // Default data
        const defaultTasks = [
            { id: 1, name: 'Project Planning', type: 'group', start: '2026-01-06', end: '2026-01-20' },
            { id: 2, name: 'Requirements gathering', start: '2026-01-06', end: '2026-01-10', color: 'blue', progress: 100, assignee: 'JD' },
            { id: 3, name: 'Technical specifications', start: '2026-01-08', end: '2026-01-14', color: 'blue', progress: 75, assignee: 'AS', dependsOn: 2 },
            { id: 4, name: 'Design approval', start: '2026-01-15', end: '2026-01-15', type: 'milestone', dependsOn: 3 },
            { id: 5, name: 'Development', type: 'group', start: '2026-01-13', end: '2026-02-07' },
            { id: 6, name: 'Frontend development', start: '2026-01-13', end: '2026-01-28', color: 'green', progress: 40, assignee: 'MK' },
            { id: 7, name: 'Backend API', start: '2026-01-15', end: '2026-01-30', color: 'purple', progress: 30, assignee: 'JD', dependsOn: 4 },
            { id: 8, name: 'Database setup', start: '2026-01-13', end: '2026-01-20', color: 'teal', progress: 60, assignee: 'AS' },
            { id: 9, name: 'Integration', start: '2026-01-28', end: '2026-02-07', color: 'orange', progress: 0, assignee: 'MK', dependsOn: 6 },
            { id: 10, name: 'Testing & Launch', type: 'group', start: '2026-02-02', end: '2026-02-20' },
            { id: 11, name: 'QA Testing', start: '2026-02-02', end: '2026-02-12', color: 'pink', progress: 0, assignee: 'QA', dependsOn: 9 },
            { id: 12, name: 'Bug fixes', start: '2026-02-10', end: '2026-02-17', color: 'orange', progress: 0, assignee: 'JD', dependsOn: 11 },
            { id: 13, name: 'Launch', start: '2026-02-20', end: '2026-02-20', type: 'milestone', dependsOn: 12 },
        ];

        // Utility functions
        function daysBetween(d1, d2) {
            return Math.round((d2 - d1) / (1000 * 60 * 60 * 24));
        }

        function formatDate(date) {
            return date.toISOString().split('T')[0];
        }

        function parseDate(str) {
            const d = new Date(str + 'T00:00:00');
            return d;
        }

        function getWeekNumber(date) {
            const d = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()));
            const dayNum = d.getUTCDay() || 7;
            d.setUTCDate(d.getUTCDate() + 4 - dayNum);
            const yearStart = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));
            return Math.ceil((((d - yearStart) / 86400000) + 1) / 7);
        }

        function calculateDateRange() {
            if (tasks.length === 0) {
                startDate = new Date(today);
                startDate.setDate(startDate.getDate() - 7);
                endDate = new Date(today);
                endDate.setDate(endDate.getDate() + 60);
                return;
            }

            let minDate = parseDate(tasks[0].start);
            let maxDate = parseDate(tasks[0].end);

            tasks.forEach(t => {
                const s = parseDate(t.start);
                const e = parseDate(t.end);
                if (s < minDate) minDate = s;
                if (e > maxDate) maxDate = e;
            });

            startDate = new Date(minDate);
            startDate.setDate(startDate.getDate() - 7);
            endDate = new Date(maxDate);
            endDate.setDate(endDate.getDate() + 14);
        }

        // Local Storage
        function saveToStorage() {
            localStorage.setItem(STORAGE_KEY, JSON.stringify(tasks));
        }

        function loadFromStorage() {
            const data = localStorage.getItem(STORAGE_KEY);
            if (data) {
                tasks = JSON.parse(data);
            } else {
                tasks = [...defaultTasks];
            }
        }

        // Undo/Redo functionality
        function createSnapshot() {
            return JSON.parse(JSON.stringify(tasks));
        }

        function pushHistory() {
            // Add current state to past history
            historyPast.push(createSnapshot());

            // Limit history size
            if (historyPast.length > MAX_HISTORY) {
                historyPast.shift();
            }

            // Clear future history when new action is performed
            historyFuture = [];

            updateUndoRedoButtons();
        }

        function undo() {
            if (historyPast.length === 0) return;

            // Save current state to future
            historyFuture.push(createSnapshot());

            // Restore previous state
            tasks = historyPast.pop();

            saveToStorage();
            render();
            updateUndoRedoButtons();
            showToast('Undo');
        }

        function redo() {
            if (historyFuture.length === 0) return;

            // Save current state to past
            historyPast.push(createSnapshot());

            // Restore future state
            tasks = historyFuture.pop();

            saveToStorage();
            render();
            updateUndoRedoButtons();
            showToast('Redo');
        }

        function updateUndoRedoButtons() {
            const undoBtn = document.getElementById('undoBtn');
            const redoBtn = document.getElementById('redoBtn');

            if (undoBtn) {
                undoBtn.disabled = historyPast.length === 0;
            }
            if (redoBtn) {
                redoBtn.disabled = historyFuture.length === 0;
            }
        }

        function saveSettings() {
            const settings = {
                currentView,
                sidebarWidth
            };
            localStorage.setItem(SETTINGS_KEY, JSON.stringify(settings));
        }

        function loadSettings() {
            const data = localStorage.getItem(SETTINGS_KEY);
            if (data) {
                const settings = JSON.parse(data);
                currentView = settings.currentView || 'days';
                sidebarWidth = settings.sidebarWidth || 300;
                applySidebarWidth();
                updateViewLabel();
            }
        }

        // Export/Import
        function exportData() {
            const dataStr = JSON.stringify(tasks, null, 2);
            const blob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'gantt-project.json';
            a.click();
            URL.revokeObjectURL(url);
            showToast('Project exported successfully!');
        }

        function importData(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    // Save history before importing
                    pushHistory();

                    tasks = JSON.parse(e.target.result);
                    saveToStorage();
                    render();
                    showToast('Project imported successfully!');
                } catch (err) {
                    showToast('Invalid JSON file!');
                }
            };
            reader.readAsText(file);
            event.target.value = '';
        }

        function clearAllData() {
            if (confirm('Are you sure you want to delete all tasks?')) {
                // Save history before clearing
                pushHistory();

                tasks = [];
                saveToStorage();
                render();
                showToast('All tasks cleared');
            }
        }

        // Toast
        function showToast(message) {
            document.getElementById('toastMessage').textContent = message;
            const toast = new bootstrap.Toast(document.getElementById('toast'));
            toast.show();
        }

        // View management
        function changeView(view) {
            if (viewConfig[view]) {
                currentView = view;
                updateViewLabel();
                saveSettings();
                render();
            }
        }

        function updateViewLabel() {
            const label = viewConfig[currentView]?.label || 'Days';
            document.getElementById('viewModeLabel').textContent = label;
        }

        // Sidebar resizing
        function applySidebarWidth() {
            const sidebar = document.getElementById('taskSidebar');
            if (sidebar) {
                sidebar.style.width = `${sidebarWidth}px`;
            }
        }

        function setupSidebarResize() {
            const handle = document.getElementById('sidebarResizeHandle');
            const sidebar = document.getElementById('taskSidebar');
            let isResizing = false;
            let startX = 0;
            let startWidth = 0;

            handle.addEventListener('mousedown', (e) => {
                isResizing = true;
                startX = e.clientX;
                startWidth = sidebar.offsetWidth;
                document.body.style.cursor = 'ew-resize';
                document.body.style.userSelect = 'none';
                e.preventDefault();
            });

            document.addEventListener('mousemove', (e) => {
                if (!isResizing) return;

                const dx = e.clientX - startX;
                const newWidth = Math.max(200, Math.min(600, startWidth + dx));
                sidebar.style.width = `${newWidth}px`;
            });

            document.addEventListener('mouseup', () => {
                if (!isResizing) return;

                isResizing = false;
                document.body.style.cursor = '';
                document.body.style.userSelect = '';
                sidebarWidth = sidebar.offsetWidth;
                saveSettings();
            });
        }

        // Render functions
        function renderTimelineHeader() {
            const header = document.getElementById('timelineHeader');
            const config = viewConfig[currentView];
            const units = config.getUnits(startDate, endDate);

            if (currentView === 'days') {
                // Group by month for day view
                let html = '';
                let currentMonth = null;
                let monthUnits = [];

                units.forEach((unit, idx) => {
                    const monthKey = `${unit.month}-${unit.year}`;
                    if (currentMonth !== monthKey) {
                        if (monthUnits.length > 0) {
                            html += renderMonthGroup(monthUnits, config.cellWidth);
                        }
                        currentMonth = monthKey;
                        monthUnits = [];
                    }
                    monthUnits.push(unit);
                });

                if (monthUnits.length > 0) {
                    html += renderMonthGroup(monthUnits, config.cellWidth);
                }

                header.innerHTML = html;
            } else if (currentView === 'weeks') {
                // Group by month for week view
                let html = '';
                let currentMonth = null;
                let monthUnits = [];

                units.forEach(unit => {
                    const monthKey = `${unit.month}-${unit.year}`;
                    if (currentMonth !== monthKey) {
                        if (monthUnits.length > 0) {
                            html += renderWeekMonthGroup(monthUnits, config.cellWidth);
                        }
                        currentMonth = monthKey;
                        monthUnits = [];
                    }
                    monthUnits.push(unit);
                });

                if (monthUnits.length > 0) {
                    html += renderWeekMonthGroup(monthUnits, config.cellWidth);
                }

                header.innerHTML = html;
            } else {
                // For months, quarters, semesters, years - group by year
                let html = '';
                let currentYear = null;
                let yearUnits = [];

                units.forEach(unit => {
                    if (currentYear !== unit.year) {
                        if (yearUnits.length > 0) {
                            html += renderYearGroup(yearUnits, config.cellWidth);
                        }
                        currentYear = unit.year;
                        yearUnits = [];
                    }
                    yearUnits.push(unit);
                });

                if (yearUnits.length > 0) {
                    html += renderYearGroup(yearUnits, config.cellWidth);
                }

                header.innerHTML = html;
            }
        }

        function renderMonthGroup(units, cellWidth) {
            const firstUnit = units[0];
            const month = firstUnit.month;
            const year = firstUnit.year;
            const totalWidth = units.length * cellWidth;

            let cellsHtml = units.map(unit => {
                let classes = 'timeline-day';
                if (unit.isWeekend) classes += ' weekend';
                if (unit.isToday) classes += ' today';
                return `<div class="${classes}">${unit.label}</div>`;
            }).join('');

            return `
                <div class="timeline-month" style="width: ${totalWidth}px">
                    <div class="timeline-month-name">${month} ${year}</div>
                    <div class="timeline-days">${cellsHtml}</div>
                </div>
            `;
        }

        function renderWeekMonthGroup(units, cellWidth) {
            const firstUnit = units[0];
            const month = firstUnit.month;
            const year = firstUnit.year;
            const totalWidth = units.length * cellWidth;

            let cellsHtml = units.map(unit => {
                return `<div class="timeline-day">${unit.label}</div>`;
            }).join('');

            return `
                <div class="timeline-month" style="width: ${totalWidth}px">
                    <div class="timeline-month-name">${month} ${year}</div>
                    <div class="timeline-days">${cellsHtml}</div>
                </div>
            `;
        }

        function renderYearGroup(units, cellWidth) {
            const year = units[0].year;
            const totalWidth = units.length * cellWidth;

            let cellsHtml = units.map(unit => {
                return `<div class="timeline-day">${unit.label}</div>`;
            }).join('');

            return `
                <div class="timeline-month" style="width: ${totalWidth}px">
                    <div class="timeline-month-name">${year}</div>
                    <div class="timeline-days">${cellsHtml}</div>
                </div>
            `;
        }

        function renderTaskList() {
            const list = document.getElementById('taskList');
            let html = '';

            tasks.forEach(task => {
                const isGroup = task.type === 'group';
                const isMilestone = task.type === 'milestone';

                html += `
                    <div class="task-row ${isGroup ? 'group' : ''}" data-id="${task.id}">
                        <span class="task-icon">
                            ${isGroup ? '<i class="bi bi-folder"></i>' :
                              isMilestone ? '<i class="bi bi-diamond-fill"></i>' :
                              '<i class="bi bi-check2-square"></i>'}
                        </span>
                        <span class="task-name">${task.name}</span>
                        <div class="task-actions">
                            <button class="btn btn-outline-secondary btn-sm" onclick="openTaskModal(${task.id})"><i class="bi bi-pencil"></i></button>
                        </div>
                        ${task.assignee ? `<span class="task-assignee">${task.assignee}</span>` : '<span style="width:28px"></span>'}
                    </div>
                `;
            });
            list.innerHTML = html;
        }

        function renderTimelineBody() {
            const body = document.getElementById('timelineBody');
            const config = viewConfig[currentView];
            const units = config.getUnits(startDate, endDate);
            const totalWidth = units.length * config.cellWidth;

            // Clear existing content except SVG
            const svg = document.getElementById('dependenciesLayer');
            body.innerHTML = '';
            body.appendChild(svg);

            // Render rows
            tasks.forEach((task, index) => {
                const isGroup = task.type === 'group';
                const row = document.createElement('div');
                row.className = `timeline-row ${isGroup ? 'group' : ''}`;
                row.dataset.id = task.id;

                let cellsHtml = '';
                if (currentView === 'days') {
                    // For days view, render each day
                    units.forEach(unit => {
                        let classes = 'timeline-cell';
                        if (unit.isWeekend) classes += ' weekend';
                        if (unit.isToday) classes += ' today';
                        cellsHtml += `<div class="${classes}"></div>`;
                    });
                } else {
                    // For other views, render each unit
                    units.forEach(unit => {
                        cellsHtml += `<div class="timeline-cell"></div>`;
                    });
                }
                row.innerHTML = cellsHtml;
                body.appendChild(row);
            });

            body.style.width = `${totalWidth}px`;

            // Render bars
            tasks.forEach((task, index) => {
                const taskStart = parseDate(task.start);
                const taskEnd = parseDate(task.end);
                const config = viewConfig[currentView];

                // Calculate position and width based on current view
                let startOffset, width;
                if (currentView === 'days') {
                    startOffset = daysBetween(startDate, taskStart) * config.cellWidth;
                    const duration = daysBetween(taskStart, taskEnd) + 1;
                    width = duration * config.cellWidth - 4;
                } else {
                    // For other views, calculate based on unit position
                    const allUnits = config.getUnits(startDate, endDate);

                    // Find which unit the task starts in
                    let startUnitIndex = 0;
                    let endUnitIndex = allUnits.length - 1;

                    if (currentView === 'weeks') {
                        startUnitIndex = allUnits.findIndex(u => taskStart >= u.date && taskStart <= u.endDate);
                        endUnitIndex = allUnits.findIndex(u => taskEnd >= u.date && taskEnd <= u.endDate);
                    } else if (currentView === 'months') {
                        startUnitIndex = allUnits.findIndex(u =>
                            taskStart.getFullYear() === u.date.getFullYear() &&
                            taskStart.getMonth() === u.date.getMonth()
                        );
                        endUnitIndex = allUnits.findIndex(u =>
                            taskEnd.getFullYear() === u.date.getFullYear() &&
                            taskEnd.getMonth() === u.date.getMonth()
                        );
                    } else if (currentView === 'quarters') {
                        const startQ = Math.floor(taskStart.getMonth() / 3);
                        const endQ = Math.floor(taskEnd.getMonth() / 3);
                        startUnitIndex = allUnits.findIndex(u =>
                            taskStart.getFullYear() === u.date.getFullYear() &&
                            Math.floor(u.date.getMonth() / 3) === startQ
                        );
                        endUnitIndex = allUnits.findIndex(u =>
                            taskEnd.getFullYear() === u.date.getFullYear() &&
                            Math.floor(u.date.getMonth() / 3) === endQ
                        );
                    } else if (currentView === 'semesters') {
                        const startS = Math.floor(taskStart.getMonth() / 6);
                        const endS = Math.floor(taskEnd.getMonth() / 6);
                        startUnitIndex = allUnits.findIndex(u =>
                            taskStart.getFullYear() === u.date.getFullYear() &&
                            Math.floor(u.date.getMonth() / 6) === startS
                        );
                        endUnitIndex = allUnits.findIndex(u =>
                            taskEnd.getFullYear() === u.date.getFullYear() &&
                            Math.floor(u.date.getMonth() / 6) === endS
                        );
                    } else if (currentView === 'years') {
                        startUnitIndex = allUnits.findIndex(u => taskStart.getFullYear() === u.date.getFullYear());
                        endUnitIndex = allUnits.findIndex(u => taskEnd.getFullYear() === u.date.getFullYear());
                    }

                    if (startUnitIndex === -1) startUnitIndex = 0;
                    if (endUnitIndex === -1) endUnitIndex = allUnits.length - 1;

                    startOffset = startUnitIndex * config.cellWidth;
                    width = (endUnitIndex - startUnitIndex + 1) * config.cellWidth - 4;
                }

                const top = index * rowHeight;

                if (task.type === 'milestone') {
                    const el = document.createElement('div');
                    el.className = 'milestone';
                    el.style.left = `${startOffset + (config.cellWidth/2) - 10}px`;
                    el.style.top = `${top + 12}px`;
                    el.dataset.id = task.id;
                    el.ondblclick = () => openTaskModal(task.id);
                    body.appendChild(el);
                } else if (task.type === 'group') {
                    const bar = document.createElement('div');
                    bar.className = 'gantt-bar group-bar';
                    bar.style.left = `${startOffset + 2}px`;
                    bar.style.width = `${width}px`;
                    bar.style.top = `${top + 18}px`;
                    bar.dataset.id = task.id;
                    body.appendChild(bar);
                } else {
                    const bar = document.createElement('div');
                    bar.className = `gantt-bar ${task.color || 'blue'}`;
                    bar.style.left = `${startOffset + 2}px`;
                    bar.style.width = `${width}px`;
                    bar.style.top = `${top + 10}px`;
                    bar.dataset.id = task.id;

                    let innerHTML = '';
                    if (task.progress > 0) {
                        innerHTML += `<div class="progress-fill" style="width: ${task.progress}%"></div>`;
                    }
                    innerHTML += `<span class="bar-label">${task.name}</span>`;
                    innerHTML += `<div class="resize-handle left"></div>`;
                    innerHTML += `<div class="resize-handle right"></div>`;
                    bar.innerHTML = innerHTML;

                    // Drag & resize
                    setupDragAndResize(bar, task);
                    bar.ondblclick = () => openTaskModal(task.id);
                    body.appendChild(bar);
                }
            });

            // Today line (only for day/week views)
            if (currentView === 'days' || currentView === 'weeks') {
                let todayOffset = 0;
                if (currentView === 'days') {
                    todayOffset = daysBetween(startDate, today) * config.cellWidth + (config.cellWidth / 2);
                } else if (currentView === 'weeks') {
                    const allUnits = config.getUnits(startDate, endDate);
                    const todayUnitIndex = allUnits.findIndex(u => today >= u.date && today <= u.endDate);
                    if (todayUnitIndex !== -1) {
                        todayOffset = todayUnitIndex * config.cellWidth + (config.cellWidth / 2);
                    }
                }

                if (todayOffset >= 0 && todayOffset <= totalWidth) {
                    const todayLine = document.createElement('div');
                    todayLine.className = 'today-line';
                    todayLine.style.left = `${todayOffset}px`;
                    todayLine.style.height = `${tasks.length * rowHeight}px`;
                    body.appendChild(todayLine);
                }
            }

            document.getElementById('timelineWrapper').style.width = `${totalWidth}px`;

            // Render dependencies
            renderDependencies();
        }

        function renderDependencies() {
            const svg = document.getElementById('dependenciesLayer');
            const config = viewConfig[currentView];
            const units = config.getUnits(startDate, endDate);
            const totalWidth = units.length * config.cellWidth;
            svg.setAttribute('width', totalWidth);
            svg.setAttribute('height', tasks.length * rowHeight);

            // Remove old paths
            svg.querySelectorAll('path').forEach(p => p.remove());

            tasks.forEach((task, index) => {
                if (!task.dependsOn) return;

                const depIndex = tasks.findIndex(t => t.id === task.dependsOn);
                if (depIndex === -1) return;

                const depTask = tasks[depIndex];
                const depEnd = parseDate(depTask.end);
                const taskStart = parseDate(task.start);

                let x1, x2;
                if (currentView === 'days') {
                    x1 = daysBetween(startDate, depEnd) * config.cellWidth + config.cellWidth;
                    x2 = daysBetween(startDate, taskStart) * config.cellWidth;
                } else {
                    // Calculate unit indices for non-day views
                    const allUnits = units;
                    let depEndIndex = 0, taskStartIndex = 0;

                    if (currentView === 'weeks') {
                        depEndIndex = allUnits.findIndex(u => depEnd >= u.date && depEnd <= u.endDate);
                        taskStartIndex = allUnits.findIndex(u => taskStart >= u.date && taskStart <= u.endDate);
                    } else if (currentView === 'months') {
                        depEndIndex = allUnits.findIndex(u =>
                            depEnd.getFullYear() === u.date.getFullYear() &&
                            depEnd.getMonth() === u.date.getMonth()
                        );
                        taskStartIndex = allUnits.findIndex(u =>
                            taskStart.getFullYear() === u.date.getFullYear() &&
                            taskStart.getMonth() === u.date.getMonth()
                        );
                    } else if (currentView === 'quarters') {
                        const depQ = Math.floor(depEnd.getMonth() / 3);
                        const taskQ = Math.floor(taskStart.getMonth() / 3);
                        depEndIndex = allUnits.findIndex(u =>
                            depEnd.getFullYear() === u.date.getFullYear() &&
                            Math.floor(u.date.getMonth() / 3) === depQ
                        );
                        taskStartIndex = allUnits.findIndex(u =>
                            taskStart.getFullYear() === u.date.getFullYear() &&
                            Math.floor(u.date.getMonth() / 3) === taskQ
                        );
                    } else if (currentView === 'semesters') {
                        const depS = Math.floor(depEnd.getMonth() / 6);
                        const taskS = Math.floor(taskStart.getMonth() / 6);
                        depEndIndex = allUnits.findIndex(u =>
                            depEnd.getFullYear() === u.date.getFullYear() &&
                            Math.floor(u.date.getMonth() / 6) === depS
                        );
                        taskStartIndex = allUnits.findIndex(u =>
                            taskStart.getFullYear() === u.date.getFullYear() &&
                            Math.floor(u.date.getMonth() / 6) === taskS
                        );
                    } else if (currentView === 'years') {
                        depEndIndex = allUnits.findIndex(u => depEnd.getFullYear() === u.date.getFullYear());
                        taskStartIndex = allUnits.findIndex(u => taskStart.getFullYear() === u.date.getFullYear());
                    }

                    if (depEndIndex === -1) depEndIndex = allUnits.length - 1;
                    if (taskStartIndex === -1) taskStartIndex = 0;

                    x1 = (depEndIndex + 1) * config.cellWidth;
                    x2 = taskStartIndex * config.cellWidth;
                }

                const y1 = depIndex * rowHeight + rowHeight / 2;
                const y2 = index * rowHeight + rowHeight / 2;

                const midX = (x1 + x2) / 2;
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('class', 'dependency-line');
                path.setAttribute('d', `M ${x1} ${y1} C ${midX} ${y1}, ${midX} ${y2}, ${x2} ${y2}`);
                svg.appendChild(path);
            });
        }

        // Drag and resize
        function setupDragAndResize(bar, task) {
            let isDragging = false;
            let isResizing = false;
            let resizeDir = null;
            let startX = 0;
            let origLeft = 0;
            let origWidth = 0;

            bar.addEventListener('mousedown', (e) => {
                if (e.target.classList.contains('resize-handle')) {
                    isResizing = true;
                    resizeDir = e.target.classList.contains('left') ? 'left' : 'right';
                } else {
                    isDragging = true;
                }
                bar.classList.add('dragging');
                startX = e.clientX;
                origLeft = parseInt(bar.style.left);
                origWidth = parseInt(bar.style.width);
                e.preventDefault();
            });

            document.addEventListener('mousemove', (e) => {
                if (!isDragging && !isResizing) return;

                const config = viewConfig[currentView];
                const cellWidth = config.cellWidth;
                const dx = e.clientX - startX;
                const unitsDelta = Math.round(dx / cellWidth);

                if (isDragging) {
                    bar.style.left = `${origLeft + unitsDelta * cellWidth}px`;
                } else if (isResizing) {
                    if (resizeDir === 'right') {
                        const newWidth = origWidth + unitsDelta * cellWidth;
                        if (newWidth >= cellWidth) {
                            bar.style.width = `${newWidth}px`;
                        }
                    } else {
                        const newWidth = origWidth - unitsDelta * cellWidth;
                        if (newWidth >= cellWidth) {
                            bar.style.left = `${origLeft + unitsDelta * cellWidth}px`;
                            bar.style.width = `${newWidth}px`;
                        }
                    }
                }
            });

            document.addEventListener('mouseup', () => {
                if (!isDragging && !isResizing) return;

                bar.classList.remove('dragging');

                // Get current view config
                const config = viewConfig[currentView];
                const cellWidth = config.cellWidth;

                // Calculate new position
                const newLeft = parseInt(bar.style.left) - 2;
                const newWidth = parseInt(bar.style.width) + 4;
                const startUnits = Math.round(newLeft / cellWidth);
                const durationUnits = Math.round(newWidth / cellWidth);

                // Calculate new dates based on current view
                let newStart, newEnd;

                if (currentView === 'days') {
                    // For days view, direct day calculation
                    newStart = new Date(startDate);
                    newStart.setDate(newStart.getDate() + startUnits);
                    newEnd = new Date(newStart);
                    newEnd.setDate(newEnd.getDate() + durationUnits - 1);
                } else {
                    // For other views, find the unit and calculate dates
                    const units = config.getUnits(startDate, endDate);

                    if (startUnits >= 0 && startUnits < units.length) {
                        const startUnit = units[startUnits];
                        newStart = new Date(startUnit.date);

                        const endUnitIndex = Math.min(startUnits + durationUnits - 1, units.length - 1);
                        const endUnit = units[endUnitIndex];

                        if (currentView === 'weeks' && endUnit.endDate) {
                            newEnd = new Date(endUnit.endDate);
                        } else if (currentView === 'months') {
                            // End of month
                            newEnd = new Date(endUnit.date.getFullYear(), endUnit.date.getMonth() + 1, 0);
                        } else if (currentView === 'quarters') {
                            // End of quarter
                            const quarterMonth = Math.floor(endUnit.date.getMonth() / 3) * 3 + 2;
                            newEnd = new Date(endUnit.date.getFullYear(), quarterMonth + 1, 0);
                        } else if (currentView === 'semesters') {
                            // End of semester
                            const semesterMonth = Math.floor(endUnit.date.getMonth() / 6) * 6 + 5;
                            newEnd = new Date(endUnit.date.getFullYear(), semesterMonth + 1, 0);
                        } else if (currentView === 'years') {
                            // End of year
                            newEnd = new Date(endUnit.date.getFullYear(), 11, 31);
                        } else {
                            newEnd = new Date(endUnit.date);
                        }
                    } else {
                        // Fallback to original dates if calculation fails
                        newStart = parseDate(task.start);
                        newEnd = parseDate(task.end);
                    }
                }

                // Check if dates actually changed
                const oldStart = parseDate(task.start);
                const oldEnd = parseDate(task.end);

                if (newStart.getTime() !== oldStart.getTime() || newEnd.getTime() !== oldEnd.getTime()) {
                    // Save history before making changes
                    pushHistory();

                    // Calculate how many days the task moved
                    const daysMoved = daysBetween(oldStart, newStart);

                    task.start = formatDate(newStart);
                    task.end = formatDate(newEnd);

                    // Cascade changes to dependent tasks
                    if (daysMoved !== 0) {
                        shiftDependentTasks(task.id, daysMoved);
                    }

                    saveToStorage();
                    render(); // Full re-render to update all bars
                }

                isDragging = false;
                isResizing = false;
                resizeDir = null;
            });
        }

        // Find all tasks that depend on a given task (recursively)
        function getDependentTasks(taskId, visited = new Set()) {
            if (visited.has(taskId)) return []; // Prevent circular dependencies
            visited.add(taskId);

            const dependents = [];
            tasks.forEach(t => {
                if (t.dependsOn === taskId) {
                    dependents.push(t);
                    // Recursively get tasks that depend on this one
                    dependents.push(...getDependentTasks(t.id, visited));
                }
            });
            return dependents;
        }

        // Shift all dependent tasks by a number of days
        function shiftDependentTasks(taskId, daysMoved) {
            const dependents = getDependentTasks(taskId);

            dependents.forEach(depTask => {
                const depStart = parseDate(depTask.start);
                const depEnd = parseDate(depTask.end);

                depStart.setDate(depStart.getDate() + daysMoved);
                depEnd.setDate(depEnd.getDate() + daysMoved);

                depTask.start = formatDate(depStart);
                depTask.end = formatDate(depEnd);
            });

            if (dependents.length > 0) {
                showToast(`Shifted ${dependents.length} dependent task${dependents.length > 1 ? 's' : ''}`);
            }
        }

        // Task Modal
        function openTaskModal(id = null) {
            const modal = new bootstrap.Modal(document.getElementById('taskModal'));
            const isEdit = id !== null;

            document.getElementById('taskModalTitle').textContent = isEdit ? 'Edit Task' : 'Add Task';
            document.getElementById('deleteTaskBtn').style.display = isEdit ? 'block' : 'none';

            // Populate dependency dropdown
            const depSelect = document.getElementById('taskDependency');
            depSelect.innerHTML = '<option value="">None</option>';
            tasks.forEach(t => {
                if (t.id !== id && t.type !== 'group') {
                    depSelect.innerHTML += `<option value="${t.id}">${t.name}</option>`;
                }
            });

            if (isEdit) {
                const task = tasks.find(t => t.id === id);
                document.getElementById('taskId').value = id;
                document.getElementById('taskName').value = task.name;
                document.getElementById('taskType').value = task.type || 'task';
                document.getElementById('taskStart').value = task.start;
                document.getElementById('taskEnd').value = task.end;
                document.getElementById('taskAssignee').value = task.assignee || '';
                document.getElementById('taskProgress').value = task.progress || 0;
                document.getElementById('progressValue').textContent = task.progress || 0;
                document.getElementById('taskDependency').value = task.dependsOn || '';

                // Set color
                document.querySelectorAll('.color-option').forEach(el => {
                    el.classList.toggle('selected', el.dataset.color === (task.color || 'blue'));
                });
            } else {
                document.getElementById('taskId').value = '';
                document.getElementById('taskName').value = '';
                document.getElementById('taskType').value = 'task';
                document.getElementById('taskStart').value = formatDate(today);
                const nextWeek = new Date(today);
                nextWeek.setDate(nextWeek.getDate() + 7);
                document.getElementById('taskEnd').value = formatDate(nextWeek);
                document.getElementById('taskAssignee').value = '';
                document.getElementById('taskProgress').value = 0;
                document.getElementById('progressValue').textContent = 0;
                document.getElementById('taskDependency').value = '';
                document.querySelectorAll('.color-option').forEach(el => {
                    el.classList.toggle('selected', el.dataset.color === 'blue');
                });
            }

            toggleTaskFields();
            modal.show();
        }

        function toggleTaskFields() {
            const type = document.getElementById('taskType').value;
            const taskFields = document.getElementById('taskFields');
            const endDateCol = document.getElementById('endDateCol');

            taskFields.style.display = type === 'task' ? 'block' : 'none';
            endDateCol.style.display = type === 'milestone' ? 'none' : 'block';

            if (type === 'milestone') {
                document.getElementById('taskEnd').value = document.getElementById('taskStart').value;
            }
        }

        function saveTask() {
            const id = document.getElementById('taskId').value;
            const name = document.getElementById('taskName').value.trim();
            const type = document.getElementById('taskType').value;
            const start = document.getElementById('taskStart').value;
            let end = document.getElementById('taskEnd').value;

            if (!name || !start) {
                showToast('Please fill in required fields');
                return;
            }

            if (type === 'milestone') end = start;

            const taskData = {
                id: id ? parseInt(id) : Date.now(),
                name,
                type: type === 'task' ? undefined : type,
                start,
                end,
            };

            if (type === 'task') {
                taskData.assignee = document.getElementById('taskAssignee').value.trim() || undefined;
                taskData.progress = parseInt(document.getElementById('taskProgress').value);
                taskData.color = document.querySelector('.color-option.selected')?.dataset.color || 'blue';
                const dep = document.getElementById('taskDependency').value;
                if (dep) taskData.dependsOn = parseInt(dep);
            }

            // Save history before making changes
            pushHistory();

            if (id) {
                const index = tasks.findIndex(t => t.id === parseInt(id));
                tasks[index] = taskData;
            } else {
                tasks.push(taskData);
            }

            saveToStorage();
            bootstrap.Modal.getInstance(document.getElementById('taskModal')).hide();
            render();
            showToast(id ? 'Task updated' : 'Task created');
        }

        function deleteTask() {
            const id = parseInt(document.getElementById('taskId').value);
            if (confirm('Delete this task?')) {
                // Save history before making changes
                pushHistory();

                tasks = tasks.filter(t => t.id !== id);
                // Remove dependencies to this task
                tasks.forEach(t => {
                    if (t.dependsOn === id) delete t.dependsOn;
                });
                saveToStorage();
                bootstrap.Modal.getInstance(document.getElementById('taskModal')).hide();
                render();
                showToast('Task deleted');
            }
        }

        // Color picker
        document.getElementById('colorPicker').addEventListener('click', (e) => {
            if (e.target.classList.contains('color-option')) {
                document.querySelectorAll('.color-option').forEach(el => el.classList.remove('selected'));
                e.target.classList.add('selected');
            }
        });

        // Scroll to today
        function scrollToToday() {
            const timelineArea = document.getElementById('timelineArea');
            const config = viewConfig[currentView];

            let todayOffset = 0;
            if (currentView === 'days') {
                todayOffset = daysBetween(startDate, today) * config.cellWidth - timelineArea.clientWidth / 2;
            } else if (currentView === 'weeks') {
                const units = config.getUnits(startDate, endDate);
                const todayUnitIndex = units.findIndex(u => today >= u.date && today <= u.endDate);
                if (todayUnitIndex !== -1) {
                    todayOffset = todayUnitIndex * config.cellWidth - timelineArea.clientWidth / 2;
                }
            }

            timelineArea.scrollLeft = Math.max(0, todayOffset);
        }

        // Sync scroll
        function setupScrollSync() {
            const taskList = document.getElementById('taskList');
            const timelineArea = document.getElementById('timelineArea');

            taskList.addEventListener('scroll', () => {
                timelineArea.scrollTop = taskList.scrollTop;
            });

            timelineArea.addEventListener('scroll', () => {
                taskList.scrollTop = timelineArea.scrollTop;
            });
        }

        // Main render
        function render() {
            calculateDateRange();
            renderTimelineHeader();
            renderTaskList();
            renderTimelineBody();
        }

        // Color map for SVG export
        const colorMap = {
            blue: { start: '#3b82f6', end: '#2563eb' },
            green: { start: '#22c55e', end: '#16a34a' },
            purple: { start: '#8b5cf6', end: '#7c3aed' },
            orange: { start: '#f97316', end: '#ea580c' },
            pink: { start: '#ec4899', end: '#db2777' },
            teal: { start: '#14b8a6', end: '#0d9488' }
        };

        // Generate SVG content
        function generateSVG() {
            const config = viewConfig[currentView];
            const units = config.getUnits(startDate, endDate);
            const totalWidth = units.length * config.cellWidth;
            const exportSidebarWidth = sidebarWidth;
            const headerHeight = 50;
            const width = exportSidebarWidth + totalWidth;
            const height = headerHeight + tasks.length * rowHeight;

            let svg = `<svg xmlns="http://www.w3.org/2000/svg" width="${width}" height="${height}" viewBox="0 0 ${width} ${height}">`;

            // Defs for gradients and markers
            svg += `<defs>`;
            Object.entries(colorMap).forEach(([name, colors]) => {
                svg += `<linearGradient id="grad-${name}" x1="0%" y1="0%" x2="100%" y2="100%">
                    <stop offset="0%" style="stop-color:${colors.start}"/>
                    <stop offset="100%" style="stop-color:${colors.end}"/>
                </linearGradient>`;
            });
            svg += `<marker id="arrow" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                <polygon points="0 0, 10 3.5, 0 7" fill="#94a3b8"/>
            </marker>`;
            svg += `</defs>`;

            // Background
            svg += `<rect width="${width}" height="${height}" fill="#f8fafc"/>`;

            // Sidebar background
            svg += `<rect x="0" y="0" width="${exportSidebarWidth}" height="${height}" fill="white"/>`;
            svg += `<rect x="0" y="0" width="${exportSidebarWidth}" height="${headerHeight}" fill="white"/>`;
            svg += `<line x1="${exportSidebarWidth}" y1="0" x2="${exportSidebarWidth}" y2="${height}" stroke="#e2e8f0" stroke-width="2"/>`;

            // Sidebar header
            svg += `<text x="16" y="30" font-family="Arial, sans-serif" font-size="11" font-weight="600" fill="#64748b">TASK NAME</text>`;

            // Timeline header background
            svg += `<rect x="${exportSidebarWidth}" y="0" width="${totalWidth}" height="${headerHeight}" fill="white"/>`;
            svg += `<line x1="${exportSidebarWidth}" y1="${headerHeight}" x2="${width}" y2="${headerHeight}" stroke="#e2e8f0"/>`;

            // Draw timeline columns (weekends, today) - only for day view
            if (currentView === 'days') {
                let unitIndex = 0;
                units.forEach(unit => {
                    const x = exportSidebarWidth + unitIndex * config.cellWidth;
                    if (unit.isWeekend) {
                        svg += `<rect x="${x}" y="0" width="${config.cellWidth}" height="${height}" fill="#fafafa"/>`;
                    }
                    if (unit.isToday) {
                        svg += `<rect x="${x}" y="0" width="${config.cellWidth}" height="${height}" fill="#eef2ff"/>`;
                    }
                    unitIndex++;
                });
            }

            // Draw headers based on view mode
            let xOffset = exportSidebarWidth;
            if (currentView === 'days') {
                // Group by month
                let current = new Date(startDate);
                while (current <= endDate) {
                    const month = current.toLocaleString('default', { month: 'short' });
                    const year = current.getFullYear();
                    const monthStart = new Date(current);
                    const monthEnd = new Date(current.getFullYear(), current.getMonth() + 1, 0);
                    const displayEnd = monthEnd > endDate ? endDate : monthEnd;

                    let dayCount = 0;
                    for (let d = new Date(monthStart); d <= displayEnd; d.setDate(d.getDate() + 1)) {
                        const dayNum = d.getDate();
                        const dayX = xOffset + dayCount * config.cellWidth;
                        svg += `<text x="${dayX + config.cellWidth/2}" y="${headerHeight - 8}" font-family="Arial, sans-serif" font-size="10" fill="#94a3b8" text-anchor="middle">${dayNum}</text>`;
                        dayCount++;
                    }

                    const monthWidth = dayCount * config.cellWidth;
                    svg += `<text x="${xOffset + monthWidth/2}" y="18" font-family="Arial, sans-serif" font-size="11" font-weight="600" fill="#64748b" text-anchor="middle">${month} ${year}</text>`;
                    svg += `<line x1="${xOffset + monthWidth}" y1="0" x2="${xOffset + monthWidth}" y2="${headerHeight}" stroke="#e2e8f0"/>`;

                    xOffset += monthWidth;
                    current = new Date(current.getFullYear(), current.getMonth() + 1, 1);
                }
            } else {
                // For other views, render units grouped appropriately
                let currentGroup = null;
                let groupUnits = [];
                let groupKey = unit => currentView === 'weeks' || currentView === 'months' ? `${unit.month}-${unit.year}` : unit.year;

                units.forEach((unit, idx) => {
                    const key = groupKey(unit);
                    if (currentGroup !== key) {
                        if (groupUnits.length > 0) {
                            const groupWidth = groupUnits.length * config.cellWidth;
                            const groupLabel = currentView === 'weeks' || currentView === 'months' ?
                                `${groupUnits[0].month} ${groupUnits[0].year}` : currentGroup;
                            svg += `<text x="${xOffset - groupWidth + groupWidth/2}" y="18" font-family="Arial, sans-serif" font-size="11" font-weight="600" fill="#64748b" text-anchor="middle">${groupLabel}</text>`;
                        }
                        currentGroup = key;
                        groupUnits = [];
                    }

                    // Draw unit label
                    svg += `<text x="${xOffset + config.cellWidth/2}" y="${headerHeight - 8}" font-family="Arial, sans-serif" font-size="10" fill="#94a3b8" text-anchor="middle">${unit.label}</text>`;
                    groupUnits.push(unit);
                    xOffset += config.cellWidth;
                });

                // Draw last group header
                if (groupUnits.length > 0) {
                    const groupWidth = groupUnits.length * config.cellWidth;
                    const groupLabel = currentView === 'weeks' || currentView === 'months' ?
                        `${groupUnits[0].month} ${groupUnits[0].year}` : currentGroup;
                    svg += `<text x="${xOffset - groupWidth + groupWidth/2}" y="18" font-family="Arial, sans-serif" font-size="11" font-weight="600" fill="#64748b" text-anchor="middle">${groupLabel}</text>`;
                }
            }

            // Draw horizontal row lines
            for (let i = 0; i <= tasks.length; i++) {
                const y = headerHeight + i * rowHeight;
                svg += `<line x1="0" y1="${y}" x2="${width}" y2="${y}" stroke="#f1f5f9"/>`;
            }

            // Helper to escape XML special characters
            function escapeXml(str) {
                return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
            }

            // Draw task rows
            tasks.forEach((task, index) => {
                const y = headerHeight + index * rowHeight;
                const isGroup = task.type === 'group';
                const isMilestone = task.type === 'milestone';

                // Row background for groups
                if (isGroup) {
                    svg += `<rect x="0" y="${y}" width="${exportSidebarWidth}" height="${rowHeight}" fill="#f1f5f9"/>`;
                    svg += `<rect x="${exportSidebarWidth}" y="${y}" width="${totalWidth}" height="${rowHeight}" fill="#f8fafc"/>`;
                }

                // Draw icon as SVG shape instead of emoji
                const iconX = 16;
                const iconY = y + rowHeight/2;
                if (isGroup) {
                    // Folder icon
                    svg += `<rect x="${iconX}" y="${iconY - 5}" width="12" height="10" fill="#94a3b8" rx="1"/>`;
                    svg += `<rect x="${iconX}" y="${iconY - 7}" width="6" height="3" fill="#94a3b8" rx="1"/>`;
                } else if (isMilestone) {
                    // Diamond icon
                    svg += `<rect x="${iconX + 3}" y="${iconY - 5}" width="8" height="8" fill="#f97316" transform="rotate(45 ${iconX + 7} ${iconY - 1})"/>`;
                } else {
                    // Checkbox icon
                    svg += `<rect x="${iconX}" y="${iconY - 6}" width="12" height="12" fill="none" stroke="#94a3b8" stroke-width="1.5" rx="2"/>`;
                }

                // Task name in sidebar (escaped)
                const taskName = escapeXml(task.name);
                svg += `<text x="34" y="${y + rowHeight/2 + 4}" font-family="Arial, sans-serif" font-size="12" fill="#1e293b" ${isGroup ? 'font-weight="600"' : ''}>${taskName}</text>`;

                // Assignee
                if (task.assignee) {
                    svg += `<circle cx="${exportSidebarWidth - 24}" cy="${y + rowHeight/2}" r="12" fill="#818cf8"/>`;
                    svg += `<text x="${exportSidebarWidth - 24}" y="${y + rowHeight/2 + 4}" font-family="Arial, sans-serif" font-size="9" fill="white" text-anchor="middle" font-weight="600">${escapeXml(task.assignee)}</text>`;
                }
            });

            // Draw dependencies
            tasks.forEach((task, index) => {
                if (!task.dependsOn) return;
                const depIndex = tasks.findIndex(t => t.id === task.dependsOn);
                if (depIndex === -1) return;

                const depTask = tasks[depIndex];
                const depEnd = parseDate(depTask.end);
                const taskStart = parseDate(task.start);

                let x1, x2;
                if (currentView === 'days') {
                    x1 = exportSidebarWidth + daysBetween(startDate, depEnd) * config.cellWidth + config.cellWidth;
                    x2 = exportSidebarWidth + daysBetween(startDate, taskStart) * config.cellWidth;
                } else {
                    // Use same logic as renderDependencies for other views
                    let depEndIndex = 0, taskStartIndex = 0;
                    if (currentView === 'weeks') {
                        depEndIndex = units.findIndex(u => depEnd >= u.date && depEnd <= u.endDate);
                        taskStartIndex = units.findIndex(u => taskStart >= u.date && taskStart <= u.endDate);
                    } else if (currentView === 'months') {
                        depEndIndex = units.findIndex(u =>
                            depEnd.getFullYear() === u.date.getFullYear() &&
                            depEnd.getMonth() === u.date.getMonth()
                        );
                        taskStartIndex = units.findIndex(u =>
                            taskStart.getFullYear() === u.date.getFullYear() &&
                            taskStart.getMonth() === u.date.getMonth()
                        );
                    } else if (currentView === 'quarters') {
                        const depQ = Math.floor(depEnd.getMonth() / 3);
                        const taskQ = Math.floor(taskStart.getMonth() / 3);
                        depEndIndex = units.findIndex(u =>
                            depEnd.getFullYear() === u.date.getFullYear() &&
                            Math.floor(u.date.getMonth() / 3) === depQ
                        );
                        taskStartIndex = units.findIndex(u =>
                            taskStart.getFullYear() === u.date.getFullYear() &&
                            Math.floor(u.date.getMonth() / 3) === taskQ
                        );
                    } else if (currentView === 'semesters') {
                        const depS = Math.floor(depEnd.getMonth() / 6);
                        const taskS = Math.floor(taskStart.getMonth() / 6);
                        depEndIndex = units.findIndex(u =>
                            depEnd.getFullYear() === u.date.getFullYear() &&
                            Math.floor(u.date.getMonth() / 6) === depS
                        );
                        taskStartIndex = units.findIndex(u =>
                            taskStart.getFullYear() === u.date.getFullYear() &&
                            Math.floor(u.date.getMonth() / 6) === taskS
                        );
                    } else if (currentView === 'years') {
                        depEndIndex = units.findIndex(u => depEnd.getFullYear() === u.date.getFullYear());
                        taskStartIndex = units.findIndex(u => taskStart.getFullYear() === u.date.getFullYear());
                    }

                    if (depEndIndex === -1) depEndIndex = units.length - 1;
                    if (taskStartIndex === -1) taskStartIndex = 0;

                    x1 = exportSidebarWidth + (depEndIndex + 1) * config.cellWidth;
                    x2 = exportSidebarWidth + taskStartIndex * config.cellWidth;
                }

                const y1 = headerHeight + depIndex * rowHeight + rowHeight / 2;
                const y2 = headerHeight + index * rowHeight + rowHeight / 2;

                const midX = (x1 + x2) / 2;
                svg += `<path d="M ${x1} ${y1} C ${midX} ${y1}, ${midX} ${y2}, ${x2} ${y2}" fill="none" stroke="#94a3b8" stroke-width="2" marker-end="url(#arrow)"/>`;
            });

            // Draw bars
            tasks.forEach((task, index) => {
                const taskStart = parseDate(task.start);
                const taskEnd = parseDate(task.end);

                // Calculate position and width based on current view
                let startOffset, barWidth;
                if (currentView === 'days') {
                    startOffset = daysBetween(startDate, taskStart) * config.cellWidth;
                    const duration = daysBetween(taskStart, taskEnd) + 1;
                    barWidth = duration * config.cellWidth - 4;
                } else {
                    // Use same logic as renderTimelineBody for other views
                    let startUnitIndex = 0;
                    let endUnitIndex = units.length - 1;

                    if (currentView === 'weeks') {
                        startUnitIndex = units.findIndex(u => taskStart >= u.date && taskStart <= u.endDate);
                        endUnitIndex = units.findIndex(u => taskEnd >= u.date && taskEnd <= u.endDate);
                    } else if (currentView === 'months') {
                        startUnitIndex = units.findIndex(u =>
                            taskStart.getFullYear() === u.date.getFullYear() &&
                            taskStart.getMonth() === u.date.getMonth()
                        );
                        endUnitIndex = units.findIndex(u =>
                            taskEnd.getFullYear() === u.date.getFullYear() &&
                            taskEnd.getMonth() === u.date.getMonth()
                        );
                    } else if (currentView === 'quarters') {
                        const startQ = Math.floor(taskStart.getMonth() / 3);
                        const endQ = Math.floor(taskEnd.getMonth() / 3);
                        startUnitIndex = units.findIndex(u =>
                            taskStart.getFullYear() === u.date.getFullYear() &&
                            Math.floor(u.date.getMonth() / 3) === startQ
                        );
                        endUnitIndex = units.findIndex(u =>
                            taskEnd.getFullYear() === u.date.getFullYear() &&
                            Math.floor(u.date.getMonth() / 3) === endQ
                        );
                    } else if (currentView === 'semesters') {
                        const startS = Math.floor(taskStart.getMonth() / 6);
                        const endS = Math.floor(taskEnd.getMonth() / 6);
                        startUnitIndex = units.findIndex(u =>
                            taskStart.getFullYear() === u.date.getFullYear() &&
                            Math.floor(u.date.getMonth() / 6) === startS
                        );
                        endUnitIndex = units.findIndex(u =>
                            taskEnd.getFullYear() === u.date.getFullYear() &&
                            Math.floor(u.date.getMonth() / 6) === endS
                        );
                    } else if (currentView === 'years') {
                        startUnitIndex = units.findIndex(u => taskStart.getFullYear() === u.date.getFullYear());
                        endUnitIndex = units.findIndex(u => taskEnd.getFullYear() === u.date.getFullYear());
                    }

                    if (startUnitIndex === -1) startUnitIndex = 0;
                    if (endUnitIndex === -1) endUnitIndex = units.length - 1;

                    startOffset = startUnitIndex * config.cellWidth;
                    barWidth = (endUnitIndex - startUnitIndex + 1) * config.cellWidth - 4;
                }

                const x = exportSidebarWidth + startOffset + 2;
                const y = headerHeight + index * rowHeight;

                if (task.type === 'milestone') {
                    const mx = exportSidebarWidth + startOffset + config.cellWidth/2;
                    const my = y + rowHeight/2;
                    svg += `<rect x="${mx - 10}" y="${my - 10}" width="14" height="14" fill="#f97316" transform="rotate(45 ${mx} ${my})" rx="2"/>`;
                } else if (task.type === 'group') {
                    svg += `<rect x="${x}" y="${y + 18}" width="${barWidth}" height="8" fill="#475569" rx="2"/>`;
                    svg += `<polygon points="${x},${y + 26} ${x + 4},${y + 26} ${x + 2},${y + 30}" fill="#475569"/>`;
                    svg += `<polygon points="${x + barWidth},${y + 26} ${x + barWidth - 4},${y + 26} ${x + barWidth - 2},${y + 30}" fill="#475569"/>`;
                } else {
                    const color = task.color || 'blue';
                    svg += `<rect x="${x}" y="${y + 10}" width="${barWidth}" height="24" fill="url(#grad-${color})" rx="4"/>`;
                    if (task.progress > 0) {
                        svg += `<rect x="${x}" y="${y + 10}" width="${barWidth * task.progress / 100}" height="24" fill="rgba(255,255,255,0.25)" rx="4"/>`;
                    }
                    svg += `<text x="${x + 8}" y="${y + 26}" font-family="Arial, sans-serif" font-size="11" fill="white" font-weight="500">${escapeXml(task.name)}</text>`;
                }
            });

            // Today line (only for day/week views)
            if (currentView === 'days' || currentView === 'weeks') {
                let todayOffset = 0;
                if (currentView === 'days') {
                    todayOffset = daysBetween(startDate, today) * config.cellWidth + config.cellWidth / 2;
                } else if (currentView === 'weeks') {
                    const todayUnitIndex = units.findIndex(u => today >= u.date && today <= u.endDate);
                    if (todayUnitIndex !== -1) {
                        todayOffset = todayUnitIndex * config.cellWidth + config.cellWidth / 2;
                    }
                }

                if (todayOffset >= 0 && todayOffset <= totalWidth) {
                    const tx = exportSidebarWidth + todayOffset;
                    svg += `<line x1="${tx}" y1="${headerHeight}" x2="${tx}" y2="${height}" stroke="#ef4444" stroke-width="2"/>`;
                    svg += `<text x="${tx}" y="${headerHeight - 5}" font-family="Arial, sans-serif" font-size="9" fill="#ef4444" text-anchor="middle" font-weight="600">Today</text>`;
                }
            }

            svg += `</svg>`;
            return svg;
        }

        // Export as SVG
        function exportAsSVG() {
            const svg = generateSVG();
            const blob = new Blob([svg], { type: 'image/svg+xml' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'gantt-chart.svg';
            a.click();
            URL.revokeObjectURL(url);
            showToast('SVG exported successfully!');
        }

        // Export as PNG
        function exportAsPNG() {
            showToast('Generating PNG...');
            const svg = generateSVG();

            // Parse SVG to get dimensions
            const parser = new DOMParser();
            const svgDoc = parser.parseFromString(svg, 'image/svg+xml');
            const svgEl = svgDoc.documentElement;
            const width = parseInt(svgEl.getAttribute('width'));
            const height = parseInt(svgEl.getAttribute('height'));

            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const scale = 2; // 2x for better quality

            canvas.width = width * scale;
            canvas.height = height * scale;
            ctx.scale(scale, scale);

            // Fill background
            ctx.fillStyle = '#f8fafc';
            ctx.fillRect(0, 0, width, height);

            const img = new Image();

            img.onload = () => {
                ctx.drawImage(img, 0, 0, width, height);

                // Convert to PNG and download
                const pngUrl = canvas.toDataURL('image/png');
                const a = document.createElement('a');
                a.href = pngUrl;
                a.download = 'gantt-chart.png';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                showToast('PNG exported successfully!');
            };

            img.onerror = (e) => {
                console.error('PNG export error:', e);
                showToast('Error generating PNG - try SVG instead');
            };

            // Use base64 data URL instead of blob URL for better compatibility
            const svgBase64 = btoa(unescape(encodeURIComponent(svg)));
            img.src = 'data:image/svg+xml;base64,' + svgBase64;
        }

        // Keyboard shortcuts
        function setupKeyboardShortcuts() {
            document.addEventListener('keydown', (e) => {
                // Ctrl+Z or Cmd+Z for undo
                if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
                    e.preventDefault();
                    undo();
                }
                // Ctrl+Y or Cmd+Y or Ctrl+Shift+Z for redo
                else if ((e.ctrlKey || e.metaKey) && (e.key === 'y' || (e.key === 'z' && e.shiftKey))) {
                    e.preventDefault();
                    redo();
                }
            });
        }

        // Initialize
        loadFromStorage();
        loadSettings();
        render();
        setupScrollSync();
        setupSidebarResize();
        setupKeyboardShortcuts();
        updateUndoRedoButtons();
        setTimeout(scrollToToday, 100);
    </script>
</body>
</html>
